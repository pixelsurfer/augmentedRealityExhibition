/*============================================================================== 
 * Copyright (c) 2012-2014 Qualcomm Connected Experiences, Inc. All Rights Reserved. 
 * ==============================================================================*/

using UnityEngine;
using System.Collections;
using Vuforia;

/// <summary>
/// UI Event Handler class that handles events generated by user-tap actions
/// over the UI Options Menu
/// </summary>
public class VideoPlaybackUIEventHandler : ISampleAppUIEventHandler
{

    #region PUBLIC_MEMBER_VARIABLES
    public override event System.Action CloseView;
    public override event System.Action GoToAboutPage;
    public bool mFullScreenMode;
    #endregion PUBLIC_MEMBER_VARIABLES

    #region PRIVATE_MEMBER_VARIABLES
    private VideoPlaybackUIView mView;
    #endregion PRIVATE_MEMBER_VARIABLES

    #region PUBLIC_MEMBER_PROPERTIES
    public VideoPlaybackUIView View
    {
        get
        {
            if (mView == null)
            {
                mView = new VideoPlaybackUIView();
                mView.LoadView();
            }
            return mView;
        }
    }

    /// <summary>
    /// Currently, there is no mechanism to query the SDK to know whether or not extended tracking is enabled/disabled.
    /// Therefore, it needs to be handled at the app layer.
    /// </value>
    public static bool ExtendedTrackingIsEnabled
    {
        get
        {
            return false;
        }
    }
    #endregion PUBLIC_MEMBER_PROPERTIES

    #region PUBLIC_METHODS
    public override void UpdateView(bool tf)
    {
        this.View.UpdateUI(tf);
    }

    public override void Bind()
    {
        this.View.mCloseButton.TappedOn += OnTappedOnCloseButton;
        this.View.mAboutLabel.TappedOn += OnTappedOnAboutButton;
        this.View.mPlayFullscreeSettings.TappedOn += OnTappedOnFullscreenButton;

        // register Vuforia started callback
        VuforiaAbstractBehaviour vuforiaBehaviour = (VuforiaAbstractBehaviour)FindObjectOfType(typeof(VuforiaAbstractBehaviour));
        if (vuforiaBehaviour)
        {
            vuforiaBehaviour.RegisterVuforiaStartedCallback(EnableContinuousAutoFocus);
            vuforiaBehaviour.RegisterOnPauseCallback(OnPause);
        }
    }

    public override void UnBind()
    {
        this.View.mCloseButton.TappedOn -= OnTappedOnCloseButton;
        this.View.mAboutLabel.TappedOn -= OnTappedOnAboutButton;
        this.View.mPlayFullscreeSettings.TappedOn -= OnTappedOnFullscreenButton;

        // unregister Vuforia started callback
        VuforiaAbstractBehaviour vuforiaBehaviour = (VuforiaAbstractBehaviour)FindObjectOfType(typeof(VuforiaAbstractBehaviour));
        if (vuforiaBehaviour)
        {
            vuforiaBehaviour.UnregisterVuforiaStartedCallback(EnableContinuousAutoFocus);
            vuforiaBehaviour.UnregisterOnPauseCallback(OnPause);
        }

        this.View.UnLoadView();
    }

    //SingleTap Gestures are captured by AppManager and calls this method for TapToFocus
    public override void TriggerAutoFocus()
    {
        StartCoroutine(TriggerAutoFocusAndEnableContinuousFocusIfSet());
    }

    #endregion PUBLIC_METHODS

    #region PRIVATE_METHODS

    /// <summary>
    /// Activating trigger autofocus mode unsets continuous focus mode (if was previously enabled from the UI Options Menu)
    /// So, we wait for a second and turn continuous focus back on (if options menu shows as enabled)
    /// </returns>
    private IEnumerator TriggerAutoFocusAndEnableContinuousFocusIfSet()
    {
        //triggers a single autofocus operation 
        if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_TRIGGERAUTO))
        {
            this.View.FocusMode = CameraDevice.FocusMode.FOCUS_MODE_TRIGGERAUTO;
        }

        yield return new WaitForSeconds(1.0f);

        //continuous focus mode is turned back on 
        if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO))
        {
            this.View.FocusMode = CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO;
        }

        Debug.Log(this.View.FocusMode);

    }

    private void OnPause(bool pause)
    {
        if (!pause)
        {
            // set to continous autofocus
            CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO);
        }
    }

    private void OnTappedOnAboutButton(bool tf)
    {
        if (this.GoToAboutPage != null)
        {
            this.GoToAboutPage();
        }
    }

    //We want autofocus to be enabled when the app starts
    private void EnableContinuousAutoFocus()
    {
        if (CameraDevice.Instance.SetFocusMode(CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO))
        {
            this.View.FocusMode = CameraDevice.FocusMode.FOCUS_MODE_CONTINUOUSAUTO;
        }
    }


    /// <summary>
    /// If the video is already playing on texture, enabling it will bring the video to full-screen
    /// otherwise, the video will play on fullscreen the next time user taps on the texture.
    /// </summary>
    /// <param name="tf"></param>
    private void OnTappedOnFullscreenButton(bool tf)
    {
        mFullScreenMode = tf;
        if (tf)
        {
            VideoPlaybackBehaviour video = PickVideo();
            if (video != null)
            {
                if (video.VideoPlayer.IsPlayableFullscreen())
                {
                    //On Android, we use Unity's built in player, so Unity application pauses before going to fullscreen. 
                    //So we have to handle the orientation from within Unity. 
#if UNITY_ANDROID
					Screen.orientation = ScreenOrientation.LandscapeLeft;
#endif
                    // Pause the video if it is currently playing
                    video.VideoPlayer.Pause();

                    // Seek the video to the beginning();
                    video.VideoPlayer.SeekTo(0.0f);

                    // Display the busy icon
                    video.ShowBusyIcon();

                    // Play the video full screen
                    StartCoroutine ( PlayVideo.PlayFullscreenVideoAtEndOfFrame(video) );
                }
            }
        }

        OnTappedToClose();
    }

    private VideoPlaybackBehaviour PickVideo()
    {
        VideoPlaybackBehaviour[] behaviours = GameObject.FindObjectsOfType(typeof(VideoPlaybackBehaviour)) as VideoPlaybackBehaviour[];
        VideoPlaybackBehaviour video = null;
        foreach (VideoPlaybackBehaviour bhvr in behaviours)
        {
            if (bhvr.CurrentState == VideoPlayerHelper.MediaState.PLAYING)
            {
                video = bhvr;
            }
        }

        return video;
    }


    private bool stopRunningObjectTracker()
    {
        bool needsObjectTrackerRestart = false;

        ObjectTracker objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>();
        if (objectTracker != null)
        {
            if (objectTracker.IsActive)
            {
                objectTracker.Stop();
                needsObjectTrackerRestart = true;
            }
        }
        return needsObjectTrackerRestart;
    }

    private bool restartRunningObjectTracker()
    {
        bool hasObjectTrackerRestarted = false;

        ObjectTracker objectTracker = TrackerManager.Instance.GetTracker<ObjectTracker>();
        if (objectTracker != null)
        {
            if (!objectTracker.IsActive)
            {
                hasObjectTrackerRestarted = objectTracker.Start();
            }
        }
        return hasObjectTrackerRestarted;
    }

    private void ResetCameraFacingToBack()
    {
        bool needsObjectTrackerRestart = stopRunningObjectTracker();

        CameraDevice.Instance.Stop();
        CameraDevice.Instance.Init(CameraDevice.CameraDirection.CAMERA_BACK);
        CameraDevice.Instance.Start();

        if (needsObjectTrackerRestart)
            restartRunningObjectTracker();
    }

    private bool ChangeCameraDirection(CameraDevice.CameraDirection direction)
    {
        bool directionSupported = false;

        bool needsObjectTrackerRestart = stopRunningObjectTracker();

        CameraDevice.Instance.Stop();
        CameraDevice.Instance.Deinit();
        if (CameraDevice.Instance.Init(direction))
        {
            directionSupported = true;
        }
        CameraDevice.Instance.Start();

        if (needsObjectTrackerRestart)
            restartRunningObjectTracker();

        return directionSupported;
    }

    private void OnTappedToClose()
    {
        if (this.CloseView != null)
        {
            this.CloseView();
        }
    }

    private void OnTappedOnCloseButton()
    {
        OnTappedToClose();
    }

    /// <summary>
    /// This method turns extended tracking on or off for all currently available targets.
    /// Extended tracking allows to track targets when they are not in view.
    /// Returns true of extended tracking is supported; false otherwise
    /// </summary>
    private bool ExtendedTracking(bool tf)
    {
        // the StateManager gives access to all available TrackableBehavours
        StateManager stateManager = TrackerManager.Instance.GetStateManager();
        // We iterate over all TrackableBehaviours to start or stop extended tracking for the targets they represent.

        bool extendedTrackingStateChanged = true;
        foreach (var behaviour in stateManager.GetTrackableBehaviours())
        {
            var imageBehaviour = behaviour as ImageTargetBehaviour;
            if (imageBehaviour != null)
            {
                if (tf)
                {
                    //only if extended tracking is supported
                    if (!imageBehaviour.ImageTarget.StartExtendedTracking())
                    {
                        extendedTrackingStateChanged = false;
                    }
                }
                else
                {
                    if (!imageBehaviour.ImageTarget.StopExtendedTracking())
                    {
                        extendedTrackingStateChanged = false;
                    }
                }
            }
        }

        if (!extendedTrackingStateChanged)
        {
            Debug.LogWarning("Extended Tracking Failed!");
        }

        return extendedTrackingStateChanged;
    }
    #endregion PRIVATE_METHODS
}
